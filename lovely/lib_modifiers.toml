[manifest]
version = "1.0.0"
dump_lua = true
priority = -1

# Apply booster pack edition and stickers to contents - by Jen Walter
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "card.T.x = self.T.x"
position = "before"
payload = '''
local edi = self.edition or {}
if edi.type and not self.ability.name:find('Standard') then
	if card.ability.name ~= "cry-meteor"
 	and card.ability.name ~= "cry-exoplanet"
  	and card.ability.name ~= "cry-stardust" then
		card:set_edition({[edi.type] = true})
  	end
end
if self.ability.eternal then
	card.ability.eternal = self.ability.eternal
end
if self.ability.perishable then
	card.ability.perishable = self.ability.perishable
end
if self.ability.rental then
	card.ability.rental = self.ability.rental
end
if self.pinned then
	card.pinned = self.pinned
end
if self.ability.banana then
	card.ability.banana = self.ability.banana
end
'''
match_indent = true

# catch edition code in standard pack to avoid reapplying edition (HORRIBLE)
[[patches]]
[patches.regex]
target = "card.lua"
pattern = '''local edition \= poll_edition\('standard_edition'\.\.G.GAME\.round_resets\.ante, edition_rate, true\)\n\s+card\:set_edition\(edition\)'''
position = "at"
payload = '''
local edi = self.edition or {}
if edi.type and not (G.GAME.modifiers.cry_force_edition and G.GAME.modifiers.cry_force_edition ~= 'random') then
	card:set_edition({[edi.type] = true})
elseif not G.GAME.modifiers.cry_force_random_edition then
	local edition = poll_edition('standard_edition'..G.GAME.round_resets.ante, edition_rate, true)
	card:set_edition(edition)
end
'''

# Edition + sticker forcing on vouchers (editions are just funny cost increases)
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "G.shop_vouchers:emplace(card)"
position = "before"
payload = '''
if G.GAME.current_round.cry_voucher_edition then
	card:set_edition(G.GAME.current_round.cry_voucher_edition, true, true)
end
if G.GAME.current_round.cry_voucher_stickers then
	if G.GAME.current_round.cry_voucher_stickers.eternal == true then		-- this is dumb but i'm not sure how to call functions from a string
		card:set_eternal(true)
		card.ability.eternal = true
	end
	if G.GAME.current_round.cry_voucher_stickers.perishable == true then
		card.ability.perishable = true
	end
	if G.GAME.current_round.cry_voucher_stickers.rental == true then
		card:set_rental(true)
		card.ability.rental = true
	end
	if G.GAME.current_round.cry_voucher_stickers.pinned == true then
		card.pinned = true
	end
	if G.GAME.current_round.cry_voucher_stickers.banana == true then
		card.ability.banana = true
	end
end
'''
match_indent = true

# don't forget voucher tags
[[patches]]
[patches.pattern]
target = "tag.lua"
pattern = "G.shop_vouchers:emplace(card)"
position = "before"
payload = '''
if G.GAME.modifiers.cry_force_edition and not G.GAME.modifiers.cry_force_random_edition then
	card:set_edition(nil, true)
elseif G.GAME.modifiers.cry_force_random_edition then
	local edition = cry_poll_random_edition()
	card:set_edition(edition, true)
end

if G.GAME.modifiers.cry_force_sticker == 'eternal' or G.GAME.modifiers.cry_sticker_sheet_plus then
	card:set_eternal(true)
	card.ability.eternal = true
end
if G.GAME.modifiers.cry_force_sticker == 'perishable' or G.GAME.modifiers.cry_sticker_sheet_plus then
	card:set_perishable(true)
	card.ability.perishable = true
end
if G.GAME.modifiers.cry_force_sticker == 'rental' or G.GAME.modifiers.cry_sticker_sheet_plus then
	card:set_rental(true)
	card.ability.rental = true
end
if G.GAME.modifiers.cry_force_sticker == 'pinned' or G.GAME.modifiers.cry_sticker_sheet_plus then
	card.pinned = true
end
if G.GAME.modifiers.cry_force_sticker == 'banana' or G.GAME.modifiers.cry_sticker_sheet_plus then
	card.ability.banana = true
end
if G.GAME.modifiers.cry_sticker_sheet_plus then
	for k, v in pairs(SMODS.Stickers) do
		if v.apply and not v.no_sticker_sheet then v:apply(card, true) end
	end
end
'''
match_indent = true

# show owned vouchers
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = "if G.GAME.used_vouchers[v.key] then"
position = "after"
payload = '''
    if not G.GAME.cry_owned_vouchers[v.key] then
        G.GAME.cry_owned_vouchers[v.key] = G.GAME.used_vouchers[v.key]
    end
end
if G.GAME.cry_owned_vouchers[v.key] then
'''
match_indent = true

# show in voucher menu
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = "voucher_areas[#voucher_areas]:emplace(card)"
position = "before"
payload = '''
if not G.GAME.voucher_edition_index then G.GAME.voucher_edition_index = {} end
if G.GAME.voucher_edition_index[card.ability.name] then		-- i just made it a function so i can look at it less
	local edition = cry_edition_to_table(G.GAME.voucher_edition_index[card.ability.name])
	if edition then
		card:set_edition(edition, true, true)
	end
end

if G.GAME.voucher_sticker_index.eternal[card.ability.name] then
	card:set_eternal(true)
	card.ability.eternal = true
end
if G.GAME.voucher_sticker_index.perishable[card.ability.name] then
	card:set_perishable(true)
	card.ability.perish_tally = G.GAME.voucher_sticker_index.perishable[card.ability.name]
	card.ability.perishable = true
	if G.GAME.voucher_sticker_index.perishable[card.ability.name] == 0 then
		card.debuff = true
	end
end
if G.GAME.voucher_sticker_index.rental[card.ability.name] then
	card:set_rental(true)
	card.ability.rental = true
end
if G.GAME.voucher_sticker_index.pinned[card.ability.name] then
	card.pinned = true
end
if G.GAME.voucher_sticker_index.banana[card.ability.name] then
	card.ability.banana = true
end
card.ability.extra = G.GAME.cry_voucher_centers[card.config.center_key].config.extra
if card.ability.extra_disp then card.ability.extra_disp = G.GAME.cry_voucher_centers[card.config.center_key].config.extra_disp end
'''
match_indent = true

# sticker tagging
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if center_table.name == 'Overstock' or center_table.name == 'Overstock Plus' then"
position = "before"
payload = '''
if not G.GAME.voucher_edition_index then G.GAME.voucher_edition_index = {} end
if self and self.edition then
	G.GAME.voucher_edition_index[center_table.name] = self.edition.type
end
if not G.GAME.voucher_sticker_index then G.GAME.voucher_sticker_index = {eternal = {}, perishable = {}, rental = {}, pinned = {}, banana = {}} end
if self and self.ability and self.ability.eternal and self.ability.eternal == true then
 	G.GAME.voucher_sticker_index.eternal[center_table.name] = true
end
if self and self.ability and self.ability.perishable and self.ability.perishable == true then
 	G.GAME.voucher_sticker_index.perishable[center_table.name] = G.GAME.cry_voucher_perishable_rounds
end
if self and self.ability and self.ability.rental and self.ability.rental == true then
 	G.GAME.voucher_sticker_index.rental[center_table.name] = true
end
if self and self.pinned and self.pinned == true then
 	G.GAME.voucher_sticker_index.pinned[center_table.name] = true
end
if self and self.ability and self.ability.banana and self.ability.banana == true then
 	G.GAME.voucher_sticker_index.banana[center_table.name] = true
end
'''
match_indent = true

# apply end of round stuff
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "if G.GAME.round_resets.ante == G.GAME.win_ante and G.GAME.blind:get_type() == 'Boss' then"
position = "before"
payload = '''
if G.GAME.voucher_sticker_index then
	if G.GAME.voucher_sticker_index.perishable then
		for k, v in pairs(G.GAME.voucher_sticker_index.perishable) do
			if v > 1 then
				G.GAME.voucher_sticker_index.perishable[k] = v - 1
			end
			if v == 1 then
				G.GAME.voucher_sticker_index.perishable[k] = v - 1	
				for kk, vv in pairs(G.P_CENTERS) do
					if k == vv.name then
						cry_debuff_voucher(kk)
						G.GAME.used_vouchers.vv = nil
						G.GAME.used_vouchers[kk] = nil
						break
					end
				end
			end
		end
	end
	if G.GAME.voucher_sticker_index.rental then
		local cumulative_rental = 0
		for k, v in pairs(G.GAME.voucher_sticker_index.rental) do
			cumulative_rental = cumulative_rental + G.GAME.cry_voucher_rental_rate
		end
		if cumulative_rental > 0 then
			G.E_MANAGER:add_event(Event({
				trigger = 'immediate',
				blocking = false,
				blockable = false,
				func = (function()
					ease_dollars(-cumulative_rental)
				return true
			end)}))
		end
	end
	if G.GAME.voucher_sticker_index.banana then		-- i'm pretty sure unredeem breaks if spectrals are disabled? unsure though
		local voucher_queue = {}
		local current_round_voucher=G.GAME.current_round.voucher
		for k, v in pairs(G.GAME.voucher_sticker_index.banana) do
			if (pseudorandom('byebyevoucher') < G.GAME.probabilities.normal/G.GAME.cry_voucher_banana_odds) then
				area = G.play
				local unredeemed_voucher = ''
				for kk, vv in pairs(G.P_CENTERS) do
					if k == vv.name then
						unredeemed_voucher = kk
						break
					end
				end
			        local card = create_card('Voucher', area, nil, nil, nil, nil, unredeemed_voucher)
				if G.GAME.voucher_edition_index[card.ability.name] then		-- i made this bullshit a function
					local edition = cry_edition_to_table(G.GAME.voucher_edition_index[card.ability.name])
					if edition then
						card:set_edition(edition, true, true)
					end
				end
				if G.GAME.voucher_sticker_index.eternal[card.ability.name] then
	    				card:set_eternal(true)
	    				card.ability.eternal = true
				end
				if G.GAME.voucher_sticker_index.perishable[card.ability.name] then
	    				card:set_perishable(true)
	    				card.ability.perish_tally = G.GAME.voucher_sticker_index.perishable[card.ability.name]
	    				card.ability.perishable = true
	    				if G.GAME.voucher_sticker_index.perishable[card.ability.name] == 0 then
						card.debuff = true
					end
				end
				if G.GAME.voucher_sticker_index.rental[card.ability.name] then
	   				card:set_rental(true)
	  				card.ability.rental = true
				end
				if G.GAME.voucher_sticker_index.pinned[card.ability.name] then
					card.pinned = true
				end
				if G.GAME.voucher_sticker_index.banana[card.ability.name] then
					card.ability.banana = true
				end
        			card:start_materialize()
        			area:emplace(card)
        			card.cost=0
        			card.shop_voucher=false
				voucher_queue[#voucher_queue+1] = card
			end
		end
		for k, v in pairs(voucher_queue) do
			v:unredeem()
        		G.E_MANAGER:add_event(Event({
				trigger = 'after',
				delay =  0,
				func = function() 
					v:start_dissolve()
				return true
			end}))
		end
		G.GAME.current_round.voucher=current_round_voucher
	end
end
'''
match_indent = true

# Affect booster packs
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "G.shop_booster:emplace(card)"
position = "before"
payload = '''
if G.GAME.modifiers.cry_force_edition and not G.GAME.modifiers.cry_force_random_edition then
	card:set_edition(nil, true, true)
elseif G.GAME.modifiers.cry_force_random_edition then
	local edition = cry_poll_random_edition()
	card:set_edition(edition, true, true)
end

local eternal_perishable_poll = pseudorandom('cry_bpet'..(key_append or '')..G.GAME.round_resets.ante)
if (G.GAME.modifiers.cry_force_sticker == 'eternal') or (G.GAME.modifiers.cry_sticker_sheet_plus) or (G.GAME.modifiers.cry_any_stickers and (G.GAME.modifiers.enable_eternals_in_shop and eternal_perishable_poll > 0.8)) then	
	card:set_eternal(true)
	card.ability.eternal = true
end
if G.GAME.modifiers.enable_perishables_in_shop and G.GAME.modifiers.cry_any_stickers then	-- i don't feel like messing with this, whatever
	if not G.GAME.modifiers.cry_eternal_perishable_compat and ((eternal_perishable_poll > 0.6) and (eternal_perishable_poll <= 0.8)) then
		card:set_perishable(true)
		card.ability.perishable = true
	end
	if G.GAME.modifiers.cry_eternal_perishable_compat and pseudorandom('cry_bpper'..(key_append or '')..G.GAME.round_resets.ante) > 0.8 then
		card:set_perishable(true)
		card.ability.perishable = true
	end
end
if (G.GAME.modifiers.cry_force_sticker == 'perishable') or (G.GAME.modifiers.cry_sticker_sheet_plus) then
	card:set_perishable(true)
	card.ability.perishable = true
end
if (G.GAME.modifiers.cry_force_sticker == 'rental') or (G.GAME.modifiers.cry_sticker_sheet_plus) or (G.GAME.modifiers.cry_any_stickers and (G.GAME.modifiers.enable_rentals_in_shop and pseudorandom('cry_bpssjr'..(key_append or '')..G.GAME.round_resets.ante) > 0.8)) then	-- i should really just make this a function? so messy
	card.ability.rental = true	-- do not set_rental here to prevent cost from decreasing
end
if (G.GAME.modifiers.cry_force_sticker == 'pinned') or (G.GAME.modifiers.cry_sticker_sheet_plus) or (G.GAME.modifiers.cry_any_stickers and (G.GAME.modifiers.cry_enable_pinned_in_shop and pseudorandom('cry_bppin'..(key_append or '')..G.GAME.round_resets.ante) > 0.8)) then
	card.pinned = true
end
if G.GAME.modifiers.cry_force_sticker == 'banana' or G.GAME.modifiers.cry_sticker_sheet_plus then
	card.ability.banana = true
end
if not G.GAME.modifiers.cry_eternal_perishable_compat and G.GAME.modifiers.enable_banana and G.GAME.modifiers.cry_any_stickers and (pseudorandom('cry_bpbanana'..(key_append or '')..G.GAME.round_resets.ante) > 0.8) and (eternal_perishable_poll <= 0.8) then
	card.ability.banana = true
end
if G.GAME.modifiers.cry_eternal_perishable_compat and G.GAME.modifiers.enable_banana and G.GAME.modifiers.cry_any_stickers and (pseudorandom('cry_bpbanana'..(key_append or '')..G.GAME.round_resets.ante) > 0.8) then
	card.ability.banana = true
end
if G.GAME.modifiers.cry_sticker_sheet_plus then
	for k, v in pairs(SMODS.Stickers) do
		if v.apply and not v.no_sticker_sheet then v:apply(card, true) end
	end
end
'''
match_indent = true

# world's first actually good multi-patch
[[patches]]
[patches.pattern]
target = "tag.lua"
pattern = "card:start_materialize()"
position = "before"
payload = '''
if G.GAME.modifiers.cry_force_edition and not G.GAME.modifiers.cry_force_random_edition then
	card:set_edition(nil, true, true)
elseif G.GAME.modifiers.cry_force_random_edition then
	local edition = cry_poll_random_edition()
	card:set_edition(edition, true, true)
end
'''
match_indent = true



# don't draw old perishable texture
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''if self.ability.perishable then'''
position = "at"
payload = '''if self.ability.perishable and not layer then'''
match_indent = true

# Adds cry_debuff_immune card modifier
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = 'if self.ability and self.ability.perma_debuff then self.debuff = true end'
position = "after"
payload = '''
if self.cry_debuff_immune then
	self.debuff = false
end
'''
match_indent = true

# Removes cry_debuff_immune at the end of the round
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = 'for i = 1, #G.jokers.cards do'
position = "before"
payload = '''
for i = 1, #G.playing_cards do
	local CARD = G.playing_cards[i]
    CARD.cry_debuff_immune = false
end
'''
match_indent = true
